<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>360天球の中にオブジェクトを配置（Three.js）</title>
  <style>
    html,body { height:100%; margin:0; }
    canvas { display:block; }
    #hint {
      position: fixed; left: 10px; bottom: 10px;
      color:#cfd8dc; background: rgba(0,0,0,.4);
      font: 12px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      padding: 6px 8px; border-radius: 6px; user-select: none;
    }
  </style>
</head>
<body>
  <div id="hint">マウス左ドラッグ: 回転 / 右ドラッグ: パン / ホイール: ズーム</div>

  <!-- Three.js (ESM)＋OrbitControls＋lil-gui をCDNから -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.157.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.157.0/examples/jsm/controls/OrbitControls.js";
    import { GUI } from "https://unpkg.com/lil-gui@0.19/dist/lil-gui.esm.js";

    // ====== 基本セットアップ ======
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 1.6, 2); // 若干前に出して見やすく
    scene.add(camera);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 軸＆グリッド（目安）
    const axes = new THREE.AxesHelper(1.0);
    scene.add(axes);
    const grid = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
    grid.position.y = 0;
    scene.add(grid);

    // ====== 天球（内貼り球） ======
    // あなたの 2:1 JPEG を指定（例: ./pano.jpg）
    const EQUIRECT_URL = "SD8F.jpg"; // ←ファイル名を合わせる
    const loader = new THREE.TextureLoader();
    loader.load(
      EQUIRECT_URL,
      (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace; // sRGBとして表示
        tex.mapping = THREE.EquirectangularReflectionMapping; // equirectマッピング

        // 内側が見える巨大スフィア
        const radius = 1000; // 大きければOK（カメラの遠クリップ内に収まる範囲）
        const sphereGeo = new THREE.SphereGeometry(radius, 64, 32);
        const sphereMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.BackSide });
        const sky = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(sky);
      },
      undefined,
      (err) => {
        console.error("天球テクスチャの読み込みに失敗:", err);
      }
    );

    // ====== 薄い立方体（床っぽい板） ======
    // サイズは GUI で調整可能
    const boxGeo = new THREE.BoxGeometry(1, 0.02, 1);
    const boxMat = new THREE.MeshStandardMaterial({ color: 0x88aaff, roughness: 0.8, metalness: 0.0 });
    const box = new THREE.Mesh(boxGeo, boxMat);
    box.position.set(0, 0.01, -1.0); // とりあえず目の前に
    scene.add(box);

    // 簡単なライト（天球は影響を受けないが、オブジェクトは受ける）
    const amb = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(2, 5, 2);
    scene.add(dir);

    // 影っぽいフェイク（半透明の円）※本物の影ではない
    const shadowGeo = new THREE.CircleGeometry(0.6, 32);
    const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2 });
    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = 0.001;
    shadow.position.z = -1.0;
    scene.add(shadow);

    // ====== GUI ======
    const gui = new GUI();
    const params = {
      boxX: box.position.x,
      boxY: box.position.y,
      boxZ: box.position.z,
      rotY_deg: THREE.MathUtils.radToDeg(box.rotation.y),
      sizeX: 1.0,
      sizeZ: 1.0,
      shadowOpacity: 0.2,
      // 方位＋距離指定（天球の見た目に合わせて“方向だけ”合わせたいときの補助）
      yaw_deg: 0, // Y軸回り（東西南北）
      dist: 1.0,
      applyYawDist: () => {
        const yaw = THREE.MathUtils.degToRad(params.yaw_deg);
        box.position.set(Math.sin(yaw) * params.dist, box.position.y, -Math.cos(yaw) * params.dist);
        shadow.position.set(box.position.x, 0.001, box.position.z);
        syncControllers();
      },
    };

    const f1 = gui.addFolder("Box (位置/回転/サイズ)");
    f1.add(params, "boxX", -5, 5, 0.01).onChange(v => { box.position.x = v; shadow.position.x = v; });
    f1.add(params, "boxY", 0, 2, 0.001).onChange(v => { box.position.y = v; });
    f1.add(params, "boxZ", -5, 5, 0.01).onChange(v => { box.position.z = v; shadow.position.z = v; });
    f1.add(params, "rotY_deg", -180, 180, 1).name("回転Y(°)").onChange(v => { box.rotation.y = THREE.MathUtils.degToRad(v); });
    f1.add(params, "sizeX", 0.1, 5, 0.01).name("サイズX").onChange(v => { box.scale.x = v; });
    f1.add(params, "sizeZ", 0.1, 5, 0.01).name("サイズZ").onChange(v => { box.scale.z = v; });
    f1.add(params, "shadowOpacity", 0, 1, 0.01).name("影の濃さ").onChange(v => { shadow.material.opacity = v; });
    f1.open();

    const f2 = gui.addFolder("方位で置く（お手軽）");
    f2.add(params, "yaw_deg", -180, 180, 1).name("方位(°) 左=-/右=+");
    f2.add(params, "dist", 0.1, 5, 0.01).name("距離");
    f2.add(params, "applyYawDist").name("この方位/距離で配置");
    f2.open();

    function syncControllers(){
      params.boxX = box.position.x;
      params.boxY = box.position.y;
      params.boxZ = box.position.z;
      gui.controllersRecursive().forEach(c => c.updateDisplay && c.updateDisplay());
    }

    // ====== レイアウト対応 ======
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ====== ループ ======
    renderer.setAnimationLoop(() => {
      controls.update();
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>

